{"version":3,"file":"paginated-resources-SauKRGLr.js","sources":["../../../common/foundation/resources/client/datatable/requests/paginated-resources.ts"],"sourcesContent":["import { useQuery, UseQueryOptions } from '@tanstack/react-query';\nimport { useRef } from 'react';\nimport { PaginatedBackendResponse } from '../../http/backend-response/pagination-response';\nimport { apiClient } from '../../http/query-client';\n\nexport interface GetDatatableDataParams {\n  orderBy?: string;\n  orderDir?: 'asc' | 'desc';\n  filters?: string | null;\n  query?: string;\n  with?: string;\n  perPage?: number | string | null;\n  page?: number | string | null;\n  paginate?: 'simple' | 'lengthAware' | 'preferLengthAware' | 'cursor';\n  [key: string]: string | number | boolean | undefined | null;\n}\n\nexport const DatatableDataQueryKey = (\n  endpoint: string,\n  params?: GetDatatableDataParams | Record<string, string | number | boolean>,\n  baseQueryKey?: string[],\n) => {\n  // split endpoint by slash, so we can clear cache from the root later,\n  // for example, 'link-group' will clear 'link-group/1/links' endpoint\n  const key: (string | GetDatatableDataParams)[] = baseQueryKey\n    ? [...baseQueryKey]\n    : endpoint.split('/');\n  if (params) {\n    key.push(params);\n  }\n  return key;\n};\n\nexport function useDatatableData<T = object>(\n  endpoint: string,\n  params: GetDatatableDataParams,\n  options?: Omit<\n    UseQueryOptions<\n      PaginatedBackendResponse<T>,\n      unknown,\n      PaginatedBackendResponse<T>,\n      any[]\n    >,\n    'queryKey' | 'queryFn'\n  > & {baseQueryKey?: string[]},\n  onLoad?: (data: PaginatedBackendResponse<T>) => void,\n) {\n  if (!params.paginate) {\n    params.paginate = 'preferLengthAware';\n  }\n  // having queryKey in option will cause unnecessary re-fetching\n  const optionsQueryKey = options?.baseQueryKey;\n  delete options?.baseQueryKey;\n  const previousData = useRef<PaginatedBackendResponse<T> | undefined>(undefined);\n  const query = useQuery({\n    ...options,\n    queryKey: DatatableDataQueryKey(endpoint, params, optionsQueryKey),\n    queryFn: ({signal}) => paginate<T>(endpoint, params, onLoad, signal),\n    // keepPreviousData ignores hits to cache, so it returns previous\n    // data from most recent fetch and not most recently show data\n    placeholderData: options?.enabled ? () => previousData.current : undefined,\n  });\n  previousData.current = query.data;\n  return query;\n}\n\nasync function paginate<T>(\n  endpoint: string,\n  params: GetDatatableDataParams,\n  onLoad?: (data: PaginatedBackendResponse<T>) => void,\n  signal?: AbortSignal,\n): Promise<PaginatedBackendResponse<T>> {\n  if (params.query) {\n    await new Promise(resolve => setTimeout(resolve, 300));\n  }\n  const response = await apiClient\n    .get(endpoint, {params, signal: params.query ? signal : undefined})\n    .then(response => response.data);\n  onLoad?.(response);\n  return response;\n}\n"],"names":["DatatableDataQueryKey","endpoint","params","baseQueryKey","key"],"mappings":"2BAiBO,MAAMA,EAAwB,CACnCC,EACAC,EACAC,IACG,CAGH,MAAMC,EAA2CD,EAC7C,CAAC,GAAGA,CAAY,EAChBF,EAAS,MAAM,GAAG,EACtB,OAAIC,GACFE,EAAI,KAAKF,CAAM,EAEVE,CACT"}