{"version":3,"file":"use-droppable-C1L4PX9b.js","sources":["../../../common/foundation/resources/client/ui/library/interactions/dnd/drag-state.ts","../../../common/foundation/resources/client/ui/library/interactions/dnd/update-rects.ts","../../../common/foundation/resources/client/ui/library/interactions/active-interaction.ts","../../../common/foundation/resources/client/ui/library/interactions/interactable-event.ts","../../../common/foundation/resources/client/ui/library/interactions/utils/dom-rect-to-obj.ts","../../../common/foundation/resources/client/ui/library/interactions/dnd/use-draggable.ts","../../../common/foundation/resources/client/ui/library/utils/array/async-iterable-to-array.ts","../../../common/foundation/resources/client/ui/library/interactions/dnd/read-files-from-data-transfer.ts","../../../common/foundation/resources/client/ui/library/interactions/dnd/use-droppable.ts"],"sourcesContent":["import {DragMonitor} from './use-drag-monitor';\nimport {ConnectedDraggable, DraggableId} from './use-draggable';\nimport {ConnectedDroppable} from './use-droppable';\n\nexport type DragSessionStatus =\n  | 'dropSuccess'\n  | 'dropFail'\n  | 'dragging'\n  | 'inactive';\n\nexport interface DragSession {\n  dragTargetId?: DraggableId;\n  status: DragSessionStatus;\n}\n\nexport const draggables = new Map<DraggableId, ConnectedDraggable>();\nexport const droppables = new Map<DraggableId, ConnectedDroppable>();\nexport const dragMonitors = new Map<DraggableId, DragMonitor>();\nexport const dragSession: DragSession = {\n  status: 'inactive',\n};\n","// use intersection observer instead of getBoundingClientRect for better performance as this will be called in onPointerMove event\nimport {InteractableRect} from '../interactable-event';\nimport {ConnectedMouseSelectable} from './mouse-selection/use-mouse-selectable';\nimport {DraggableId} from './use-draggable';\nimport {ConnectedDroppable} from './use-droppable';\n\nexport function updateRects(\n  targets: Map<DraggableId, ConnectedDroppable | ConnectedMouseSelectable>\n) {\n  const observer = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      const {width, height, left, top} = entry.boundingClientRect;\n      const [id, target] =\n        [...targets].find(\n          ([, target]) => target.ref.current === entry.target\n        ) || [];\n      if (id == null || target == null) return;\n\n      const rect: InteractableRect = {\n        width,\n        height,\n        left,\n        top,\n      };\n      targets.set(id, {...target, rect});\n    });\n    observer.disconnect();\n  });\n\n  [...targets.values()].forEach(target => {\n    if (target.ref.current) {\n      observer.observe(target.ref.current);\n    }\n  });\n}\n","type InteractionName = null | 'resize' | 'rotate' | 'drag' | 'move';\n\nexport let activeInteraction: InteractionName = null;\n\nexport function setActiveInteraction(name: InteractionName) {\n  activeInteraction = name;\n}\n","import React from 'react';\n\ntype NativeEvent =\n  | React.PointerEvent\n  | PointerEvent\n  | React.DragEvent<HTMLElement>\n  | DragEvent;\n\nexport interface InteractableEvent {\n  x: number;\n  y: number;\n  deltaX: number;\n  deltaY: number;\n  rect: InteractableRect;\n  nativeEvent: NativeEvent;\n}\n\nexport interface InteractableRect {\n  left: number;\n  top: number;\n  width: number;\n  height: number;\n  angle?: number;\n}\n\nexport function interactableEvent({\n  e,\n  rect,\n  deltaX,\n  deltaY,\n}: {\n  e: NativeEvent;\n  rect: InteractableRect;\n  deltaX?: number;\n  deltaY?: number;\n}): InteractableEvent {\n  return {\n    rect,\n    x: e.clientX,\n    y: e.clientY,\n    deltaX: deltaX ?? 0,\n    deltaY: deltaY ?? 0,\n    nativeEvent: e,\n  };\n}\n","import {InteractableRect} from '../interactable-event';\n\nexport function domRectToObj(rect: DOMRect): InteractableRect {\n  return {\n    left: rect.left,\n    top: rect.top,\n    width: rect.width,\n    height: rect.height,\n  };\n}\n","import {useGlobalListeners} from '@react-aria/utils';\nimport React, {RefObject, useLayoutEffect, useRef} from 'react';\nimport {activeInteraction, setActiveInteraction} from '../active-interaction';\nimport {\n  InteractableEvent,\n  interactableEvent,\n  InteractableRect,\n} from '../interactable-event';\nimport {domRectToObj} from '../utils/dom-rect-to-obj';\nimport {draggables, dragMonitors, dragSession, droppables} from './drag-state';\nimport {updateRects} from './update-rects';\nimport {DragMonitor} from './use-drag-monitor';\nimport {NativeFileDraggable} from './use-droppable';\n\ninterface DragState {\n  currentRect?: InteractableRect;\n  lastPosition: {x: number; y: number};\n  clickedEl?: HTMLElement;\n}\n\nexport type DragPreviewRenderer = (\n  draggable: ConnectedDraggable,\n  callback: (node: HTMLElement) => void,\n) => void;\n\nexport type DraggableId = string | number | object;\n\nexport interface ConnectedDraggable<T = any> {\n  type: string;\n  id: DraggableId;\n  getData: () => T;\n  ref: RefObject<HTMLElement | null>;\n}\n\n// Either draggable from within the app, or file dragged in from the desktop\nexport type MixedDraggable = ConnectedDraggable | NativeFileDraggable;\n\ninterface UseDragProps extends ConnectedDraggable {\n  disabled?: boolean;\n  onDragStart?: (e: InteractableEvent, target: ConnectedDraggable) => void;\n  onDragMove?: (e: InteractableEvent, target: ConnectedDraggable) => void;\n  onDragEnd?: (e: InteractableEvent, target: ConnectedDraggable) => void;\n  preview?: RefObject<DragPreviewRenderer | null>;\n  hidePreview?: boolean;\n}\nexport function useDraggable({\n  id,\n  disabled,\n  ref,\n  preview,\n  hidePreview,\n  ...options\n}: UseDragProps) {\n  const dragHandleRef = useRef<any>(null);\n  const {addGlobalListener, removeAllGlobalListeners} = useGlobalListeners();\n\n  const state = useRef<DragState>({\n    lastPosition: {x: 0, y: 0},\n  }).current;\n\n  const optionsRef = useRef(options);\n  optionsRef.current = options;\n\n  useLayoutEffect(() => {\n    if (!disabled) {\n      draggables.set(id, {\n        ...draggables.get(id),\n        id,\n        ref,\n        type: optionsRef.current.type,\n        getData: optionsRef.current.getData,\n      });\n    } else {\n      draggables.delete(id);\n    }\n    return () => {\n      draggables.delete(id);\n    };\n  }, [id, disabled, optionsRef, ref]);\n\n  // notify monitors connected to the same drag type as this draggable\n  const notifyMonitors = (callback: (m: DragMonitor) => void) => {\n    dragMonitors.forEach(monitor => {\n      if (monitor.type === draggables.get(id)?.type) {\n        callback(monitor);\n      }\n    });\n  };\n\n  const onDragStart = (e: React.DragEvent<HTMLElement>) => {\n    e.stopPropagation();\n    const draggable = draggables.get(id);\n    const el = ref.current;\n    const clickedOnHandle =\n      !dragHandleRef.current ||\n      !state.clickedEl ||\n      dragHandleRef.current.contains(state.clickedEl);\n\n    // if another interaction is in progress (rotate, resize, drag etc.), bail\n    if (activeInteraction || !el || !draggable || !clickedOnHandle) {\n      e.preventDefault();\n      e.stopPropagation();\n      return;\n    }\n\n    updateRects(droppables);\n    setActiveInteraction('drag');\n\n    // hide default browser ghost image\n    if (hidePreview) {\n      hideNativeGhostImage(e);\n    }\n    // this will hide default browser cursor icon, if \"dropEffect\" is not set in dragOver/dragEnter\n    e.dataTransfer.effectAllowed = 'move';\n\n    state.lastPosition = {x: e.clientX, y: e.clientY};\n    state.currentRect = domRectToObj(el.getBoundingClientRect());\n    const ie = interactableEvent({rect: state.currentRect!, e});\n\n    // If there is a preview option, use it to render a custom preview image that will\n    // appear under the pointer while dragging. If not, the element itself is dragged by the browser.\n    if (preview?.current) {\n      preview.current(draggable, node => {\n        e.dataTransfer.setDragImage(node, 0, 0);\n      });\n    }\n\n    dragSession.status = 'dragging';\n    dragSession.dragTargetId = id;\n    if (ref.current) {\n      ref.current.dataset.dragging = 'true';\n    }\n\n    optionsRef.current.onDragStart?.(ie, draggable);\n\n    // wait until next frame so changes made in \"onDragStart\" are reflected in drag monitors\n    requestAnimationFrame(() => {\n      notifyMonitors(m => m.onDragStart?.(ie, draggable));\n    });\n\n    // firefox does not provide clientX/clientY in \"onDrag\", need to listen for dragOver on window instead\n    addGlobalListener(window, 'dragover', onDragOver, true);\n  };\n\n  const onDragOver = (e: React.DragEvent<HTMLElement> | DragEvent) => {\n    e.stopPropagation();\n    e.preventDefault();\n\n    if (!state.currentRect) return;\n\n    const deltaX = e.clientX - state.lastPosition.x;\n    const deltaY = e.clientY - state.lastPosition.y;\n\n    const newRect = {\n      ...state.currentRect,\n      left: state.currentRect.left + deltaX,\n      top: state.currentRect.top + deltaY,\n    };\n\n    const ie = interactableEvent({rect: newRect, e, deltaX, deltaY});\n\n    const target = draggables.get(id);\n    if (target) {\n      optionsRef.current.onDragMove?.(ie, target);\n      notifyMonitors(m => m.onDragMove?.(ie, target));\n    }\n\n    state.lastPosition = {x: e.clientX, y: e.clientY};\n    state.currentRect = newRect;\n  };\n\n  const onDragEnd = (e: React.DragEvent<HTMLElement>) => {\n    e.stopPropagation();\n    removeAllGlobalListeners();\n    if (!state.currentRect) return;\n\n    setActiveInteraction(null);\n    if (emptyImage) {\n      emptyImage.remove();\n    }\n\n    const ie = interactableEvent({rect: state.currentRect, e});\n\n    const draggable = draggables.get(id);\n    if (draggable) {\n      optionsRef.current.onDragEnd?.(ie, draggable);\n      notifyMonitors(m => m.onDragEnd?.(ie, draggable, dragSession!.status));\n    }\n\n    // wait a frame before clearing so monitors have a chance to use drag session status\n    requestAnimationFrame(() => {\n      dragSession.dragTargetId = undefined;\n      dragSession.status = 'inactive';\n      if (ref.current) {\n        delete ref.current.dataset.dragging;\n      }\n    });\n  };\n\n  const draggableProps = {\n    draggable: !disabled,\n    onDragStart,\n    onDragEnd,\n    onPointerDown: (e: React.PointerEvent) => {\n      state.clickedEl = e.target as HTMLElement;\n    },\n  };\n\n  return {draggableProps, dragHandleRef};\n}\n\nlet emptyImage: HTMLImageElement | undefined;\nfunction hideNativeGhostImage(e: React.DragEvent) {\n  if (!emptyImage) {\n    emptyImage = new Image();\n    // image needs to be in the dom to prevent \"globe\" icon in chrome\n    document.body.append(emptyImage);\n    emptyImage.src =\n      'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n  }\n\n  e.dataTransfer.setDragImage(emptyImage, 0, 0);\n}\n","export async function asyncIterableToArray<T>(\n  iterator: AsyncIterable<T>\n): Promise<T[]> {\n  const items: T[] = [];\n  for await (const item of iterator) {\n    items.push(item);\n  }\n  return items;\n}\n","import {UploadedFile} from '@ui/utils/files/uploaded-file';\n\nexport async function* readFilesFromDataTransfer(dataTransfer: DataTransfer) {\n  const entries: FileSystemEntry[] = [];\n\n  // Pull out all entries before reading them, otherwise\n  // some entries will be lost due to recursion with promises\n  for (const item of dataTransfer.items) {\n    if (item.kind === 'file') {\n      const entry = item.webkitGetAsEntry();\n      if (entry) {\n        entries.push(entry);\n      }\n    }\n  }\n\n  for (const entry of entries) {\n    if (entry.isFile) {\n      if (entry.name === '.DS_Store') continue;\n      const file = await getEntryFile(entry as FileSystemFileEntry);\n      yield new UploadedFile(file, entry.fullPath);\n    } else if (entry.isDirectory) {\n      yield* getEntriesFromDirectory(entry as FileSystemDirectoryEntry);\n    }\n  }\n}\n\nasync function* getEntriesFromDirectory(\n  item: FileSystemDirectoryEntry,\n): AsyncIterable<any> {\n  const reader = item.createReader();\n\n  // We must call readEntries repeatedly because there may be a limit to the\n  // number of entries that are returned at once.\n  let entries: FileSystemEntry[];\n  do {\n    entries = await new Promise((resolve, reject) => {\n      reader.readEntries(resolve, reject);\n    });\n\n    for (const entry of entries) {\n      if (entry.isFile) {\n        if (entry.name === '.DS_Store') continue;\n        const file = await getEntryFile(entry as FileSystemFileEntry);\n        yield new UploadedFile(file, entry.fullPath);\n      } else if (entry.isDirectory) {\n        yield* getEntriesFromDirectory(entry as FileSystemDirectoryEntry);\n      }\n    }\n  } while (entries.length > 0);\n}\n\nfunction getEntryFile(entry: FileSystemFileEntry): Promise<File> {\n  return new Promise((resolve, reject) => entry.file(resolve, reject));\n}\n","import { asyncIterableToArray } from '@ui/utils/array/async-iterable-to-array';\nimport { UploadedFile } from '@ui/utils/files/uploaded-file';\nimport React, { RefObject, useLayoutEffect, useRef } from 'react';\nimport { InteractableRect } from '../interactable-event';\nimport { draggables, dragSession, droppables } from './drag-state';\nimport { readFilesFromDataTransfer } from './read-files-from-data-transfer';\nimport { DraggableId, MixedDraggable } from './use-draggable';\n\nexport interface ConnectedDroppable {\n  id: DraggableId;\n  rect?: InteractableRect;\n  disabled?: boolean;\n  ref: RefObject<HTMLElement | null>;\n}\n\n// File dragged in from desktop\nexport interface NativeFileDraggable {\n  type: 'nativeFile';\n  el: null;\n  ref: null;\n  getData: () => Promise<UploadedFile[]>;\n}\n\ninterface UseDroppableProps<T extends HTMLElement> {\n  id: DraggableId;\n  disabled?: boolean;\n  types: ('nativeFile' | string)[];\n  ref: RefObject<T | null>;\n  // this will fire dragEnter/dragLeave/dragOver events when same element is both draggable and drop target and dragging target over itself. Used for showing line previews before/after element during sort.\n  allowDragEventsFromItself?: boolean;\n  onDragEnter?: (target: MixedDraggable) => void;\n  onDragLeave?: (target: MixedDraggable) => void;\n  onDragOver?: (\n    target: MixedDraggable,\n    e: React.DragEvent<HTMLElement>,\n  ) => void;\n  // Handler that is called after draggable is held over droppable for a period of time.\n  // This typically opens the item so that the user can drop within it.\n  onDropActivate?: (e: MixedDraggable) => void;\n  onDrop?: (target: MixedDraggable) => void | Promise<void> | false;\n  acceptsDrop?: (target: MixedDraggable) => boolean;\n}\n\ninterface DroppableState {\n  dragOverElements: Set<Element>;\n  dropActivateTimer: ReturnType<typeof setTimeout> | undefined;\n}\n\nconst DROP_ACTIVATE_TIMEOUT = 400;\n\nexport function useDroppable<T extends HTMLElement>({\n  id,\n  disabled,\n  ref,\n  ...options\n}: UseDroppableProps<T>) {\n  const state = useRef<DroppableState>({\n    dragOverElements: new Set<Element>(),\n    dropActivateTimer: undefined,\n  }).current;\n\n  const optionsRef = useRef(options);\n  optionsRef.current = options;\n\n  useLayoutEffect(() => {\n    droppables.set(id, {\n      ...droppables.get(id),\n      disabled,\n      id,\n      ref,\n    });\n    return () => {\n      droppables.delete(id);\n    };\n  }, [id, optionsRef, disabled, ref]);\n\n  // check if drop target accepts drag target\n  const canDrop = (draggable: MixedDraggable): boolean => {\n    const options = optionsRef.current;\n\n    const allowEventsOnSelf =\n      options.allowDragEventsFromItself ||\n      ref.current !== draggable.ref?.current;\n\n    return !!(\n      draggable?.type &&\n      allowEventsOnSelf &&\n      options.types.includes(draggable.type) &&\n      (!options.acceptsDrop || options.acceptsDrop(draggable))\n    );\n  };\n\n  const fireDragLeave = (e: React.DragEvent<HTMLElement>) => {\n    const draggable = getDraggable(e);\n    if (draggable) {\n      optionsRef.current.onDragLeave?.(draggable);\n    }\n  };\n\n  const onDragEnter = (e: React.DragEvent<HTMLElement>) => {\n    e.stopPropagation();\n\n    state.dragOverElements.add(e.target as Element);\n    if (state.dragOverElements.size > 1) {\n      return;\n    }\n\n    const draggable = getDraggable(e);\n    if (draggable && canDrop(draggable)) {\n      optionsRef.current.onDragEnter?.(draggable);\n\n      clearTimeout(state.dropActivateTimer);\n      if (typeof optionsRef.current.onDropActivate === 'function') {\n        state.dropActivateTimer = setTimeout(() => {\n          if (draggable) {\n            optionsRef.current.onDropActivate?.(draggable);\n          }\n        }, DROP_ACTIVATE_TIMEOUT);\n      }\n    }\n  };\n\n  const onDragLeave = (e: React.DragEvent<HTMLElement>) => {\n    e.stopPropagation();\n\n    // Track all the targets of dragenter events in a set, and remove them\n    // in dragleave. When the set becomes empty, we've left the drop target completely.\n    // We must also remove any elements that are no longer in the DOM, because dragleave\n    // events will never be fired for these. This can happen, for example, with drop\n    // indicators between items, which disappear when the drop target changes.\n    state.dragOverElements.delete(e.target as Element);\n    for (const element of state.dragOverElements) {\n      if (!e.currentTarget.contains(element)) {\n        state.dragOverElements.delete(element);\n      }\n    }\n\n    if (state.dragOverElements.size > 0) {\n      return;\n    }\n\n    const draggable = getDraggable(e);\n    if (draggable && canDrop(draggable)) {\n      fireDragLeave(e);\n      clearTimeout(state.dropActivateTimer);\n    }\n  };\n\n  const onDrop = async (e: React.DragEvent<HTMLElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n    state.dragOverElements.clear();\n\n    fireDragLeave(e);\n    clearTimeout(state.dropActivateTimer);\n\n    const draggable = getDraggable(e);\n    if (draggable) {\n      optionsRef.current.onDragLeave?.(draggable);\n\n      // drop target does not accept this type of droppable\n      if (!canDrop(draggable)) {\n        if (dragSession.status !== 'inactive') {\n          dragSession.status = 'dropFail';\n        }\n        // drop target accepts this type, but it might still reject the drop in callback\n      } else {\n        // allow callback to mark drop as failed\n        const dropResult = optionsRef.current.onDrop?.(draggable);\n\n        // drag session will only be active for draggables within the app, never for files dragged in from desktop\n        if (dragSession.status !== 'inactive') {\n          dragSession.status =\n            dropResult === false ? 'dropFail' : 'dropSuccess';\n        }\n      }\n    }\n  };\n\n  const droppableProps = {\n    onDragOver: (e: React.DragEvent<HTMLElement>) => {\n      e.preventDefault();\n      e.stopPropagation();\n      const draggable = getDraggable(e);\n      if (draggable && canDrop(draggable)) {\n        optionsRef.current.onDragOver?.(draggable, e);\n      }\n    },\n    onDragEnter,\n    onDragLeave,\n    onDrop,\n  };\n\n  return {\n    droppableProps: disabled ? {} : droppableProps,\n  };\n}\n\nfunction getDraggable(\n  e: React.DragEvent<HTMLElement>,\n): MixedDraggable | undefined {\n  if (dragSession.dragTargetId != null) {\n    return draggables.get(dragSession.dragTargetId);\n  } else if (e.dataTransfer.types.includes('Files')) {\n    return {\n      type: 'nativeFile',\n      el: null,\n      ref: null,\n      getData: () => {\n        return asyncIterableToArray(readFilesFromDataTransfer(e.dataTransfer));\n      },\n    };\n  }\n}\n"],"names":["draggables","droppables","dragMonitors","dragSession","updateRects","targets","observer","entries","entry","width","height","left","top","id","target","rect","activeInteraction","setActiveInteraction","name","interactableEvent","e","deltaX","deltaY","domRectToObj","useDraggable","disabled","ref","preview","hidePreview","options","dragHandleRef","useRef","addGlobalListener","removeAllGlobalListeners","useGlobalListeners","state","optionsRef","useLayoutEffect","notifyMonitors","callback","monitor","_a","onDragStart","draggable","el","clickedOnHandle","hideNativeGhostImage","ie","node","_b","m","onDragOver","newRect","emptyImage","asyncIterableToArray","iterator","items","item","readFilesFromDataTransfer","dataTransfer","file","getEntryFile","UploadedFile","getEntriesFromDirectory","reader","resolve","reject","DROP_ACTIVATE_TIMEOUT","useDroppable","canDrop","allowEventsOnSelf","fireDragLeave","getDraggable","element","dropResult","_d","_c"],"mappings":"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"}